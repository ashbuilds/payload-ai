{"version":3,"sources":["../../../src/ai/models/convertor.ts"],"sourcesContent":["// import { RichTextDocument } from '../RichTextSchema'\n//\n// interface LexicalNode {\n//   type: string\n//   [key: string]: any\n// }\n//\n// export function convertToLexical(doc: RichTextDocument): LexicalNode {\n//   const rootNode: LexicalNode = {\n//     type: 'root',\n//     children: [],\n//   }\n//\n//   doc.document.forEach((node) => {\n//     switch (node.type) {\n//       case 'p':\n//         rootNode.children.push(convertParagraph(node))\n//         break\n//       case 'h1':\n//       case 'h2':\n//       case 'h3':\n//       case 'h4':\n//       case 'h5':\n//       case 'h6':\n//         rootNode.children.push(convertHeading(node))\n//         break\n//       case 'ul':\n//       case 'ol':\n//         rootNode.children.push(convertList(node))\n//         break\n//     }\n//   })\n//\n//   return rootNode\n// }\n//\n// function convertParagraph(node: any): LexicalNode {\n//   return {\n//     type: 'paragraph',\n//     children: node.content.map(convertTextNode),\n//   }\n// }\n//\n// function convertHeading(node: any): LexicalNode {\n//   return {\n//     type: 'heading',\n//     tag: node.type,\n//     children: [{ type: 'text', text: node.content }],\n//   }\n// }\n//\n// function convertList(node: any): LexicalNode {\n//   return {\n//     type: node.type === 'ul' ? 'unordered-list' : 'ordered-list',\n//     children: node.items.map((item: any) => ({\n//       type: 'list-item',\n//       children: [{ type: 'text', text: item.content }],\n//     })),\n//   }\n// }\n//\n// function convertTextNode(node: any): LexicalNode {\n//   if (node.type === 'text') {\n//     return { type: 'text', text: node.value }\n//   } else {\n//     return {\n//       type: node.type,\n//       children: [{ type: 'text', text: node.content }],\n//     }\n//   }\n// }\n\ninterface LexicalNode {\n  [key: string]: any\n  type: string\n}\n\ninterface MarkdownBlock {\n  content: string\n  items?: string[]\n  language?: string\n  level?: number\n  type: 'blockquote' | 'code' | 'heading' | 'list' | 'paragraph'\n}\n\nexport interface MarkdownDocument {\n  blocks: MarkdownBlock[]\n}\n\nexport function convertToLexical(doc: MarkdownDocument): LexicalNode {\n  const rootNode: LexicalNode = {\n    type: 'root',\n    children: [],\n  }\n\n  doc.blocks.forEach((block) => {\n    switch (block.type) {\n      case 'paragraph':\n        rootNode.children.push(convertParagraph(block))\n        break\n      case 'heading':\n        rootNode.children.push(convertHeading(block))\n        break\n      case 'list':\n        rootNode.children.push(convertList(block))\n        break\n      case 'code':\n        rootNode.children.push(convertCode(block))\n        break\n      case 'blockquote':\n        rootNode.children.push(convertBlockquote(block))\n        break\n    }\n  })\n\n  return rootNode\n}\n\nfunction convertParagraph(block: MarkdownBlock): LexicalNode {\n  return {\n    type: 'paragraph',\n    children: convertInlineContent(block.content),\n  }\n}\n\nfunction convertHeading(block: MarkdownBlock): LexicalNode {\n  return {\n    type: 'heading',\n    children: convertInlineContent(block.content),\n    tag: `h${block.level}`,\n  }\n}\n\nfunction convertList(block: MarkdownBlock): LexicalNode {\n  return {\n    type: 'list',\n    children:\n      block.items?.map((item) => ({\n        type: 'listitem',\n        children: convertInlineContent(item),\n      })) || [],\n    listType: 'bullet', // Assuming all lists are unordered for simplicity\n  }\n}\n\nfunction convertCode(block: MarkdownBlock): LexicalNode {\n  return {\n    type: 'code',\n    children: [{ type: 'text', text: block.content }],\n    language: block.language || '',\n  }\n}\n\nfunction convertBlockquote(block: MarkdownBlock): LexicalNode {\n  return {\n    type: 'quote',\n    children: convertInlineContent(block.content),\n  }\n}\n\nfunction convertInlineContent(content: string): LexicalNode[] {\n  // Simple implementation for inline formatting\n  const parts = content.split(/(\\*\\*.*?\\*\\*|\\*.*?\\*)/)\n  return parts.map((part) => {\n    if (part.startsWith('**') && part.endsWith('**')) {\n      return {\n        type: 'text',\n        format: 1, // Assuming 1 represents bold in Lexical\n        text: part.slice(2, -2),\n      }\n    } else if (part.startsWith('*') && part.endsWith('*')) {\n      return {\n        type: 'text',\n        format: 2, // Assuming 2 represents italic in Lexical\n        text: part.slice(1, -1),\n      }\n    } else {\n      return { type: 'text', text: part }\n    }\n  })\n}\n"],"names":["convertToLexical","doc","rootNode","type","children","blocks","forEach","block","push","convertParagraph","convertHeading","convertList","convertCode","convertBlockquote","convertInlineContent","content","tag","level","items","map","item","listType","text","language","parts","split","part","startsWith","endsWith","format","slice"],"mappings":"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"}