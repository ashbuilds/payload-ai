{"version":3,"sources":["../../../src/ai/utils/filterEditorSchemaByNodes.ts"],"sourcesContent":["import type { LexicalNodeSchema } from '../schemas/lexicalJsonSchema.js'\n\nimport { isObjectSchema } from './isObjectSchema.js'\n\nexport function filterEditorSchemaByNodes(schema: LexicalNodeSchema, allowedNodes: string[]) {\n  const allowedTypes = new Set(allowedNodes)\n\n  const filteredDefinitions: Record<string, any> = {}\n\n  // First pass: collect definitions whose \"type.enum\" includes an allowed type\n  for (const [key, def] of Object.entries(schema.definitions ?? {})) {\n    if (isObjectSchema(def)) {\n      const typeEnum = def.properties?.type?.enum\n      if (typeEnum && typeEnum.some((t) => allowedTypes.has(t))) {\n        filteredDefinitions[key] = JSON.parse(JSON.stringify(def)) // Deep copy to safely mutate\n      }\n    }\n  }\n\n  // Helper to check if a $ref points to an allowed definition\n  const isAllowedRef = (ref: string) => {\n    if (typeof ref !== 'string') {\n      return false\n    }\n    const defName = ref.replace('#/definitions/', '')\n    return defName in filteredDefinitions\n  }\n\n  // Second pass: update \"children\" in each definition to only include allowed refs\n  for (const def of Object.values(filteredDefinitions)) {\n    if (isObjectSchema(def) && def.properties?.children?.items) {\n      const items = def.properties.children.items\n\n      if (Array.isArray(items.anyOf)) {\n        // Filter anyOf to only allowed $refs\n        items.anyOf = items.anyOf.filter((entry) => isAllowedRef(entry.$ref))\n        if (items.anyOf.length === 0) {\n          delete def.properties.children\n        }\n      } else if (items.$ref && !isAllowedRef(items.$ref)) {\n        delete def.properties.children\n      }\n    }\n  }\n\n  // Return the new schema with pruned definitions\n  return {\n    ...schema,\n    definitions: filteredDefinitions,\n  }\n}\n"],"names":["isObjectSchema","filterEditorSchemaByNodes","schema","allowedNodes","allowedTypes","Set","filteredDefinitions","key","def","Object","entries","definitions","typeEnum","properties","type","enum","some","t","has","JSON","parse","stringify","isAllowedRef","ref","defName","replace","values","children","items","Array","isArray","anyOf","filter","entry","$ref","length"],"mappings":"AAEA,SAASA,cAAc,QAAQ,sBAAqB;AAEpD,OAAO,SAASC,0BAA0BC,MAAyB,EAAEC,YAAsB;IACzF,MAAMC,eAAe,IAAIC,IAAIF;IAE7B,MAAMG,sBAA2C,CAAC;IAElD,6EAA6E;IAC7E,KAAK,MAAM,CAACC,KAAKC,IAAI,IAAIC,OAAOC,OAAO,CAACR,OAAOS,WAAW,IAAI,CAAC,GAAI;QACjE,IAAIX,eAAeQ,MAAM;YACvB,MAAMI,WAAWJ,IAAIK,UAAU,EAAEC,MAAMC;YACvC,IAAIH,YAAYA,SAASI,IAAI,CAAC,CAACC,IAAMb,aAAac,GAAG,CAACD,KAAK;gBACzDX,mBAAmB,CAACC,IAAI,GAAGY,KAAKC,KAAK,CAACD,KAAKE,SAAS,CAACb,OAAM,6BAA6B;YAC1F;QACF;IACF;IAEA,4DAA4D;IAC5D,MAAMc,eAAe,CAACC;QACpB,IAAI,OAAOA,QAAQ,UAAU;YAC3B,OAAO;QACT;QACA,MAAMC,UAAUD,IAAIE,OAAO,CAAC,kBAAkB;QAC9C,OAAOD,WAAWlB;IACpB;IAEA,iFAAiF;IACjF,KAAK,MAAME,OAAOC,OAAOiB,MAAM,CAACpB,qBAAsB;QACpD,IAAIN,eAAeQ,QAAQA,IAAIK,UAAU,EAAEc,UAAUC,OAAO;YAC1D,MAAMA,QAAQpB,IAAIK,UAAU,CAACc,QAAQ,CAACC,KAAK;YAE3C,IAAIC,MAAMC,OAAO,CAACF,MAAMG,KAAK,GAAG;gBAC9B,qCAAqC;gBACrCH,MAAMG,KAAK,GAAGH,MAAMG,KAAK,CAACC,MAAM,CAAC,CAACC,QAAUX,aAAaW,MAAMC,IAAI;gBACnE,IAAIN,MAAMG,KAAK,CAACI,MAAM,KAAK,GAAG;oBAC5B,OAAO3B,IAAIK,UAAU,CAACc,QAAQ;gBAChC;YACF,OAAO,IAAIC,MAAMM,IAAI,IAAI,CAACZ,aAAaM,MAAMM,IAAI,GAAG;gBAClD,OAAO1B,IAAIK,UAAU,CAACc,QAAQ;YAChC;QACF;IACF;IAEA,gDAAgD;IAChD,OAAO;QACL,GAAGzB,MAAM;QACTS,aAAaL;IACf;AACF"}