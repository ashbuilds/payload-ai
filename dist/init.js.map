{"version":3,"sources":["../src/init.ts"],"sourcesContent":["import type { Payload } from 'payload'\n\nimport type { PluginConfig } from './types.js'\n\nimport { defaultSeedPrompts } from './ai/prompts.js'\nimport { systemGenerate } from './ai/utils/systemGenerate.js'\nimport { PLUGIN_INSTRUCTIONS_TABLE } from './defaults.js'\nimport { getGenerationModels } from './utilities/getGenerationModels.js'\n\nexport const init = async (\n  payload: Payload,\n  fieldSchemaPaths: Record<string, { label: string; relationTo?: string; type: string }>,\n  pluginConfig: PluginConfig,\n) => {\n  if (!pluginConfig.generatePromptOnInit) {\n    return\n  }\n\n  if (pluginConfig.debugging) {\n    payload.logger.info(`â€” AI Plugin: Initializing...`)\n  }\n\n  const paths = Object.keys(fieldSchemaPaths)\n\n  // Get all instructions for faster initialization\n  const { docs: allInstructions } = await payload.find({\n    collection: PLUGIN_INSTRUCTIONS_TABLE,\n    depth: 0,\n    pagination: false,\n    select: {\n      'field-type': true,\n      'schema-path': true,\n    },\n  })\n\n  const fieldInstructionsMap: Record<string, { fieldType: any; id: any }> = {}\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i]\n    const { type: fieldType, label: fieldLabel, relationTo } = fieldSchemaPaths[path]\n    let instructions = allInstructions.find((entry) => entry['schema-path'] === path)\n\n    if (!instructions) {\n      let seed\n      const seedOptions = {\n        fieldLabel,\n        fieldSchemaPaths,\n        fieldType,\n        path,\n      }\n\n      if (pluginConfig.seedPrompts) {seed = await pluginConfig.seedPrompts(seedOptions)}\n      if (seed === undefined) {seed = await defaultSeedPrompts(seedOptions)}\n      // Field should be ignored\n      if (!seed) {\n        if (pluginConfig.debugging) {\n          payload.logger.info(`â€” AI Plugin: No seed prompt for ${path}, ignoring...`)\n        }\n        continue\n      }\n\n      let generatedPrompt = '{{ title }}'\n      if ('prompt' in seed) {\n        // find the model that has the generateText function\n        const models = getGenerationModels(pluginConfig)\n        const model =\n          models && Array.isArray(models) ? models.find((model) => model.generateText) : undefined\n        generatedPrompt = await systemGenerate(\n          {\n            prompt: seed.prompt,\n            system: seed.system,\n          },\n          model?.generateText,\n        )\n      }\n\n      const modelsForId = getGenerationModels(pluginConfig)\n      const modelForId =\n        modelsForId && Array.isArray(modelsForId)\n          ? modelsForId.find((a) => a.fields.includes(fieldType))\n          : undefined\n\n      const data = {\n        'model-id': modelForId?.id,\n        prompt: generatedPrompt,\n        ...seed.data, // allow to override data, but not the one below\n        'field-type': fieldType,\n        'relation-to': relationTo,\n        'schema-path': path,\n      }\n\n      payload.logger.info(\n        {\n          'model-id': data['model-id'],\n          prompt: generatedPrompt,\n          ...seed.data,\n        },\n        `Prompt seeded for \"${path}\" field`,\n      )\n\n      instructions = (await payload\n        .create({\n          collection: PLUGIN_INSTRUCTIONS_TABLE,\n          data,\n        })\n        .catch((err) => {\n          payload.logger.error(err, 'â€” AI Plugin: Error creating Compose settings-')\n        })) as (typeof allInstructions)[0]\n\n      if (instructions?.id) {\n        fieldInstructionsMap[path] = {\n          id: instructions.id,\n          fieldType,\n        }\n      }\n    } else {\n      if (instructions['field-type'] !== fieldType) {\n        payload.logger.warn(\n          `â€” AI Plugin: Field type mismatch for ${path}! Was \"${fieldType}\", it is \"${instructions['field-type']}\" now. Updating...`,\n        )\n        await payload.update({\n          id: instructions.id,\n          collection: PLUGIN_INSTRUCTIONS_TABLE,\n          data: {\n            'field-type': fieldType,\n          },\n        })\n        instructions['field-type'] = fieldType\n      }\n\n      fieldInstructionsMap[path] = {\n        id: instructions.id,\n        fieldType,\n      }\n    }\n  }\n\n  if (pluginConfig.debugging) {\n    payload.logger.info(\n      `â€” AI Plugin: Enabled fields map: ${JSON.stringify(fieldInstructionsMap, null, 2)}`,\n    )\n    payload.logger.info(`â€” AI Plugin: Initialized!`)\n  }\n\n  if (pluginConfig.generatePromptOnInit) {\n    payload.logger.info(\n      '\\n\\n-AI Plugin: Example prompts are added to get you started, Now go break some code ðŸš€ðŸš€ðŸš€\\n\\n',\n    )\n  }\n}\n"],"names":["defaultSeedPrompts","systemGenerate","PLUGIN_INSTRUCTIONS_TABLE","getGenerationModels","init","payload","fieldSchemaPaths","pluginConfig","generatePromptOnInit","debugging","logger","info","paths","Object","keys","docs","allInstructions","find","collection","depth","pagination","select","fieldInstructionsMap","i","length","path","type","fieldType","label","fieldLabel","relationTo","instructions","entry","seed","seedOptions","seedPrompts","undefined","generatedPrompt","models","model","Array","isArray","generateText","prompt","system","modelsForId","modelForId","a","fields","includes","data","id","create","catch","err","error","warn","update","JSON","stringify"],"mappings":"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"}