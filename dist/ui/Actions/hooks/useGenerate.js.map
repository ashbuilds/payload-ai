{"version":3,"sources":["../../../../src/ui/Actions/hooks/useGenerate.ts"],"sourcesContent":["import type { LexicalEditor } from 'lexical'\n\nimport { useField, useFieldProps, useForm, useLocale } from '@payloadcms/ui'\nimport { useCompletion, experimental_useObject as useObject } from 'ai/react'\nimport { jsonrepair } from 'jsonrepair'\nimport { $getRoot } from 'lexical'\nimport { useCallback, useEffect } from 'react'\n\nimport type { GenerateTextarea, MenuItems } from '../../../types.js'\n\nimport { DocumentSchema } from '../../../ai/RichTextSchema.js'\nimport {\n  PLUGIN_API_ENDPOINT_GENERATE,\n  PLUGIN_API_ENDPOINT_GENERATE_UPLOAD,\n} from '../../../defaults.js'\nimport { useInstructions } from '../../../providers/InstructionsProvider/hook.js'\n\ntype UseGenerate = {\n  lexicalEditor: LexicalEditor\n}\n\n//TODO: DONATION IDEA - Add a url to donate in cli when user installs the plugin and uses it for couple of times.\nexport const useGenerate = ({ lexicalEditor }: UseGenerate) => {\n  const { type, path: pathFromContext, schemaPath } = useFieldProps()\n\n  //TODO: This should be dynamic, i think it was the part of component props but its not inside useFieldProps\n  const relationTo = 'media'\n\n  const { setValue } = useField<string>({\n    path: pathFromContext,\n  })\n\n  const { id: instructionId } = useInstructions({\n    path: schemaPath,\n  })\n\n  const { getData } = useForm()\n  const localFromContext = useLocale()\n\n  const {\n    isLoading: loadingObject,\n    object,\n    stop, // TODO: Implement this function\n    submit,\n  } = useObject({\n    api: `/api${PLUGIN_API_ENDPOINT_GENERATE}`,\n    onError: (error) => {\n      console.error('Error generating object:', error)\n    },\n    schema: DocumentSchema,\n  })\n\n  const {\n    complete,\n    completion,\n    isLoading: loadingCompletion,\n  } = useCompletion({\n    api: `/api${PLUGIN_API_ENDPOINT_GENERATE}`,\n    onError: (error) => {\n      console.error('Error generating text:', error)\n    },\n    streamMode: 'stream-data',\n  })\n\n  useEffect(() => {\n    if (!object) return\n\n    // TODO: Improve error handling\n    requestAnimationFrame(() => {\n      try {\n        const repairedObject = jsonrepair(JSON.stringify(object))\n        const editorState = lexicalEditor.parseEditorState(repairedObject)\n        if (editorState.isEmpty()) return\n\n        lexicalEditor.update(\n          () => {\n            const root = $getRoot()\n            root.clear() //TODO: this is hack to prevent reconciliation error - find a way\n            lexicalEditor.setEditorState(editorState)\n          },\n          {\n            discrete: true,\n          },\n        )\n      } catch (e) {\n        console.error('Error setting object:', e)\n        console.error('Object:', object)\n        if (type === 'richText') {\n          console.log('type is richText', { setValue })\n        }\n        // setValue(object) //TODO: This breaks the editor find a better way to handle objects that are not valid\n      }\n    })\n  }, [object])\n\n  useEffect(() => {\n    if (!completion) return\n\n    requestAnimationFrame(() => {\n      setValue(completion)\n    })\n  }, [completion])\n\n  const streamObject = useCallback(\n    ({ action = 'Compose' }: { action: MenuItems }) => {\n      const doc = getData()\n      const options = {\n        action,\n        instructionId,\n      }\n\n      submit({\n        doc,\n        locale: localFromContext?.code,\n        options,\n      })\n    },\n    [getData, localFromContext?.code, instructionId],\n  )\n\n  const streamText = useCallback(\n    async ({ action = 'Compose' }: { action: MenuItems }) => {\n      const doc = getData()\n      const options = {\n        action,\n        instructionId,\n      }\n\n      await complete('', {\n        body: {\n          doc,\n          locale: localFromContext?.code,\n          options,\n        },\n      })\n    },\n    [getData, localFromContext?.code, instructionId],\n  )\n\n  const generateUpload = useCallback(async () => {\n    const doc = getData()\n    return fetch(`/api${PLUGIN_API_ENDPOINT_GENERATE_UPLOAD}`, {\n      body: JSON.stringify({\n        doc,\n        locale: localFromContext?.code,\n        options: {\n          instructionId,\n          uploadCollectionSlug: relationTo,\n        },\n      } satisfies Parameters<GenerateTextarea>[0]),\n      credentials: 'include',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    })\n      .then(async (generatedImageResponse) => {\n        if (generatedImageResponse.ok) {\n          const { result: generatedImage } = await generatedImageResponse.json()\n          setValue(generatedImage?.id)\n        } else {\n          const { errors = [] } = await generatedImageResponse.json()\n          const errStr = errors.map((error) => error.message).join(', ')\n          throw new Error(errStr)\n        }\n        return generatedImageResponse\n      })\n      .catch((error) => {\n        console.error('Error generating image', error)\n      })\n  }, [getData, localFromContext?.code, instructionId, relationTo, setValue])\n\n  const generate = useCallback(\n    async (options?: { action: MenuItems }) => {\n      if (type === 'richText') {\n        return streamObject(options)\n      }\n\n      if (['text', 'textarea'].includes(type)) {\n        return streamText(options)\n      }\n      if (type === 'upload') {\n        return generateUpload()\n      }\n    },\n    [generateUpload, streamObject, streamText, type],\n  )\n\n  return {\n    generate,\n    isLoading: loadingCompletion || loadingObject,\n  }\n}\n"],"names":["useField","useFieldProps","useForm","useLocale","useCompletion","experimental_useObject","useObject","jsonrepair","$getRoot","useCallback","useEffect","DocumentSchema","PLUGIN_API_ENDPOINT_GENERATE","PLUGIN_API_ENDPOINT_GENERATE_UPLOAD","useInstructions","useGenerate","lexicalEditor","type","path","pathFromContext","schemaPath","relationTo","setValue","id","instructionId","getData","localFromContext","isLoading","loadingObject","object","stop","submit","api","onError","error","console","schema","complete","completion","loadingCompletion","streamMode","requestAnimationFrame","repairedObject","JSON","stringify","editorState","parseEditorState","isEmpty","update","root","clear","setEditorState","discrete","e","log","streamObject","action","doc","options","locale","code","streamText","body","generateUpload","fetch","uploadCollectionSlug","credentials","headers","method","then","generatedImageResponse","ok","result","generatedImage","json","errors","errStr","map","message","join","Error","catch","generate","includes"],"mappings":"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"}