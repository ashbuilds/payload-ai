{"version":3,"sources":["../../src/utilities/setSafeLexicalState.ts"],"sourcesContent":["import type { LexicalEditor } from 'lexical'\n\nimport { $getRoot } from 'lexical'\n\nexport const setSafeLexicalState = (state, editorInstance: LexicalEditor) => {\n  try {\n    const editorState = editorInstance.parseEditorState(state)\n    if (editorState.isEmpty()) return\n\n    editorInstance.update(\n      () => {\n        const root = $getRoot()\n        root.clear() //TODO: this is hack to prevent reconciliation error - find a way\n        editorInstance.setEditorState(editorState)\n      },\n      {\n        discrete: true,\n      },\n    )\n  } catch (e) {\n    // console.error('Error setting object:', e)\n    // if (type === 'richText') {\n    // console.log('Object:', result)\n    // console.log('type is richText', { setValue })\n    // }\n    // setValue(object) //TODO: This breaks the editor find a better way to handle objects that are not valid\n  }\n}\n"],"names":["$getRoot","setSafeLexicalState","state","editorInstance","editorState","parseEditorState","isEmpty","update","root","clear","setEditorState","discrete","e"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,UAAS;AAElC,OAAO,MAAMC,sBAAsB,CAACC,OAAOC;IACzC,IAAI;QACF,MAAMC,cAAcD,eAAeE,gBAAgB,CAACH;QACpD,IAAIE,YAAYE,OAAO,IAAI;QAE3BH,eAAeI,MAAM,CACnB;YACE,MAAMC,OAAOR;YACbQ,KAAKC,KAAK,GAAG,iEAAiE;;YAC9EN,eAAeO,cAAc,CAACN;QAChC,GACA;YACEO,UAAU;QACZ;IAEJ,EAAE,OAAOC,GAAG;IACV,4CAA4C;IAC5C,6BAA6B;IAC7B,iCAAiC;IACjC,gDAAgD;IAChD,IAAI;IACJ,yGAAyG;IAC3G;AACF,EAAC"}